// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void startWorker(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FfiSchedule)>>
        submitSchedule,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> notifyStopped,
    FfiProblem problem,
  ) {
    return _startWorker(
      submitSchedule,
      notifyStopped,
      problem,
    );
  }

  late final _startWorkerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FfiSchedule)>>,
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>,
              FfiProblem)>>('startWorker');
  late final _startWorker = _startWorkerPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(FfiSchedule)>>,
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>,
          FfiProblem)>();

  void stopWorker() {
    return _stopWorker();
  }

  late final _stopWorkerPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('stopWorker');
  late final _stopWorker = _stopWorkerPtr.asFunction<void Function()>();
}

class FfiFraction extends ffi.Struct {
  @ffi.Int32()
  external int numerator;

  @ffi.Int32()
  external int denominator;
}

class i2fracEntry extends ffi.Struct {
  @ffi.Int32()
  external int key;

  external FfiFraction value;
}

class i2frac extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<i2fracEntry> entries;
}

class i2iEntry extends ffi.Struct {
  @ffi.Int32()
  external int key;

  @ffi.Int32()
  external int value;
}

class i2i extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<i2iEntry> entries;
}

class i2i2iEntry extends ffi.Struct {
  @ffi.Int32()
  external int key;

  external i2i value;
}

class i2i2i extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<i2i2iEntry> entries;
}

abstract class MachineType {
  static const int REACTION_ = 0;
  static const int MANUFACTURING_ = 1;
}

/// / Schedule
class batchItem extends ffi.Struct {
  @ffi.Int32()
  external int runs;

  @ffi.Int32()
  external int slots;

  external FfiFraction time;
}

class i2batchItemEntry extends ffi.Struct {
  @ffi.Int32()
  external int key;

  external batchItem value;
}

class batch extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<i2batchItemEntry> entries;
}

class batchList extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<batch> entries;
}

class k2batchesEntry extends ffi.Struct {
  @ffi.Int32()
  external int key;

  external batchList value;
}

class k2batches extends ffi.Struct {
  @ffi.Int32()
  external int size;

  external ffi.Pointer<k2batchesEntry> entries;
}

class FfiSchedule extends ffi.Struct {
  external k2batches machine2batches;

  @ffi.Double()
  external double time;

  @ffi.Int32()
  external int optimal;

  @ffi.Int32()
  external int infeasible;
}

class FfiProblem extends ffi.Struct {
  external i2i runsExcess;

  external i2i madePerRun;

  external i2i timePerRun;

  external i2i job2machine;

  external i2i2i dependencies;

  external i2i inventory;

  external i2i maxNumSlotsOfMachine;

  external i2i maxNumSlotsOfJob;

  external i2i maxNumRunsPerSlotOfJob;

  external i2frac materialBonus;

  external i2frac timeBonus;

  @ffi.Int32()
  external int float2int;

  external ffi.Pointer<FfiSchedule> approximation;
}
